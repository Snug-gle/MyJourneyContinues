[[RealMySQL 8.0]]
9.3 고급 최적화
- MySQL 서버의 옵티마이저가 실행 계획을 수립할 때 통계정보와 옵티마이저의 옵션을  결합해서 최적의 실행 계획을 수립.
9.3.1 옵티마이저 스위치 옵션 `optimizer_switch`
9.3.1.1 MRR과 배치 키 액세스
- Multi-Range Read
- MySQL 서버의 내부 구조상 조인 처리는 MySQL 엔진이 처리
- 실제 레코드를 검색하고 읽는 부분은 스토리지 엔진이 담당
- 네스티드 루프 조인 시, 스토리지 엔진에서는 아무런 최적화를 수행할 수 없는 단점이 발생
- 위의 단점을 보완하기 위해 MySQL에서는 버퍼링을 사용
- 조인 시, 즉시 하지 않고 조인 대상을 버퍼링 함
- 레코드가 가득차면 비로소 MySQL 엔진은 버퍼링된 레코드를 스토리지 엔진으로 한 번에 요청
---
- gpt
MRR은 다음과 같은 방식으로 작동합니다:

1. **인덱스 스캔**: 먼저 쿼리의 조건에 맞는 인덱스를 스캔하여, 필요한 모든 인덱스 포인터(키와 실제 레코드의 포인터)를 수집합니다.
2. **버퍼링**: 수집된 인덱스 포인터를 순서에 관계없이 버퍼에 저장합니다.
3. **정렬**: 버퍼링된 인덱스 포인터를 실제 레코드의 저장 위치에 따라 정렬합니다. 이렇게 하면 물리적인 저장 순서에 따라 데이터를 읽을 수 있으므로 디스크 I/O를 최적화할 수 있습니다.
4. **데이터 액세스**: 정렬된 포인터에 따라 실제 데이터 레코드를 읽습니다. 이 과정에서 디스크로의 접근이 순차적으로 이루어지므로 I/O 비용이 감소합니다.
---
9.3.1.2 블록 네스티드 루프 조인(block_nested_loop)
- 네스티드 루프 조인과의 가장 큰 차이는 조인 버퍼(`join_buffer_size`)가 사용되는 지 여부 + 조인에서 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인 되느냐
- 조인 알고리즘에서 "Block"이라는 단어가 사용되면 조인용으로 별도의 버퍼가 사용됐다는 것을 의미
- 
---
- gpt
### 작동 원리

블록 네스티드 루프 조인은 다음과 같은 단계로 작동합니다:

1. **메모리 버퍼 할당**: 조인을 수행하기 위해 메모리 상에 버퍼를 할당합니다. 이 버퍼는 내부 테이블의 행을 저장하는 데 사용됩니다.
    
2. **내부 테이블 캐싱**: 내부 테이블의 행들을 메모리 버퍼에 적재합니다. 이 단계에서는 가능한 많은 행을 한 번에 메모리로 가져옵니다.
    
3. **외부 테이블 스캔**: 외부 테이블의 각 행을 순차적으로 검사하면서 메모리에 적재된 내부 테이블의 행들과 비교합니다.
    
4. **조인 조건 검사**: 외부 테이블의 현재 행과 내부 테이블의 모든 행을 조인 조건에 따라 비교합니다. 조건에 맞는 행을 찾으면 결과 집합에 추가합니다.
    
5. **반복 실행**: 내부 테이블의 모든 행이 메모리에 한 번에 적재되지 않는 경우, 다음 그룹의 행을 메모리에 적재하고 과정을 반복합니다.
--- 