[[RealMySQL 8.0]]
서버로 요청된 쿼리는 결과는 동일하지만 내부적으로 그 결과를 만들어내는 방법은 매우 다양
기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요 -> 옵티마이저의 기능

### 9.1 개요
- 실행 계획을 이해할 수 있어야만 실행 계획의 불합리한 부분을 찾아낼 수 있음
#### 9.1.1 쿼리 실행 절차
- SQL 파싱: 요청된 SQL 문을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리) ex. SQL문이 문법적으로 잘못됐다면 이 단계에서 걸러짐
- 최적화 및 실행 계획 수립: SQL의 파싱정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
- 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

#### 9.1.2 옵티마이저의 종류
- 규칙 기반 최적화 방법
	- 통계정보를 조사하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
	- 같은 쿼리에 대해서는 항상 같은 실행 방법을 만들어 낸다
	- 현재 거의 사용 하지 않음
- 비용 기반 최적화 방법
	- 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
### 9.2 기본 데이터 처리
- 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있으나, RDBMS별로 그 결과를 만들어 내는 과정에 차이가 있음
#### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
- 풀 테이블 스캔: 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업
- InnoDB 스토리지 엔진
	- 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작
		`리드 어헤드: 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미`(백그라운드 프로세스)
	- 포그라운드 프로세스에서 백그라운드 프로세스가 읽기를 넘겨 받는 시점부터 페이지를 읽으면서 그 수를 증가시킴
- 풀 인덱스 스캔: 인덱스를 처음부터 끝까지 스캔하는 것
- `SELECT COUNT(*) FROM employees;` -> 풀 인덱스 스캔
- `SELECT * FROM emplyess;` -> 풀 테이블 스캔
#### 9.2.2 병렬 처리 `innodb_parallel_read_threads`
- 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미
- 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어듬(서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있음)
#### 9.2.3 ORDER BY 처리(Using filesort)
- 데이터 웨어하우스: 조직의 다양한 출처에서 수집한 데이터를 통합하여 저장하는 시스템
- 정렬을 처리하는 방법
	- 인덱스 이용
	- Filesort 이용
		- filesort: 정렬 작업을 메모리 내에서 완료할 수 없을 때, 파일 기반의 정렬 알고리즘인 'filesort' 를 사용
#### 9.2.3.1 소트 버퍼 `sort_buffer_size`
- 소트 버퍼: 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데, 이 메모리 공간을 소트 버퍼라 함. 사용 후 즉시 반납
- 만약, 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면?
	- mysql은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용
- 멀티 머지: 각 버퍼 크기 만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행하는 것 `Sort_merge_passes`
- 이 작업들은 모두 디스크의 쓰기와 읽기를 유발하며, 레코드의 건수가 많을 수록 이 반복 작업의 횟수가 많아짐
- ``` select * from salaries order by to_date limit 99999999,1; 이 쿼리에서 to_date 컬럼에 인덱스가 있다면 물리적으로 정렬된 상태로 저장
- 일반적인 트랜잭션 처리용 mysql 서버의 소트 버퍼 크기는 56KB ~ 1MB 미만
- 정렬을 위해 할당하는 소트 버퍼는 세션 메모리에 해당. 즉, 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아니므로 커넥션이 많을 수록, 정렬 작업이 많으면 말을 수록 메모리 공간이 커짐. 이때 OOM-Killer의 강제 종료 1순위
- 
#### 9.2.3.2 정렬 알고리즘
- Single-Pass: 이 알고리즘은 데이터를 한 번의 패스로 정렬하는 방식. 메모리 내에서 모든 데이터를 정렬할 수 있을 때 주로 사용
- Two-Pass: 두 단계에 걸쳐 파일 기반 정렬을 수행
	- 가능한 많은 데이터를 메모리 내에서 정렬하고, 메모리 용량을 초과하는 데이터는 디스크에 저정된 임시 파일로 쓰임. 
- 임시 파일들을 병합 정렬 방식으로 최종 정렬을 완성
- sort_algorithm 필드: 쿼리의 정렬 작업을 처리하는 데 사용된 정렬 알고리즘의 유형
- sort_mode 필드: 정렬 시 사용된 데이터의 저장 방식

#### 9.2.3.2.1 싱글 패스 정렬 방식
- 소트 버퍼에 정렬 기준 칼럼을 포함해 select 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식
#### 9.2.3.2.2 투 패스 정렬 방식
- 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select할 칼럼을 가져오는 정렬 방식
- 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 불합리하지만, 싱글 패스는 없다
- 하지만 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용
#### 9.2.3.3 정렬 처리 방법
- order by가 사용되면 반드시 아래 3가지 처리 방법 중 하나로 정렬이 처리됨. 일반적으로 아래족에 있는 정렬 방법으로 갈수록 처리 속도가 떨어짐
	1. 인덱스를 사용한 정렬: 실행 계획의 Extra 컬럼 내용에 별도 표기 없음
	2. 조인에서 드라이빙 테이블만 연결: "Using filesort" 메세지가 표시
	3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: "Using temporary; Using filesort" 메세지가 표시
	* 드라이빙 테이블: 조인을 수행할 때 사용되는 테이블 중 하나는 "드라이빙 테이블" 이라고 함. 조인연산에 리더십을 취한다
#### 9.2.3.3.1 인덱스를 이용한 
- 반드시 group by에 명시된 칼럼이 드라이빙 테이블에 속하고, order by의 순서대로 생성된 인덱스가 있어야 한다.
- 

#### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬

#### 9.2.3.3.3 임시 테이블을 이용한 정렬